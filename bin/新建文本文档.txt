#include "AudioStream.h"


void AudioStream::initav()
{
	av_register_all();
	avformat_network_init();
}

int AudioStream::initAudio(int freq,int channels,int samples)
{
	av_register_all();
	avformat_network_init();


	SDL_AudioSpec want;

	SDL_memset(&want, 0, sizeof(want)); /* or SDL_zero(want) */
	want.freq = freq;
	want.format = AUDIO_F32;
	want.channels = 2;
	want.samples = 4096;
	want.callback = nullptr; /* you wrote this function elsewhere. */

	dev = SDL_OpenAudioDevice(NULL, 0, &want, &spec, SDL_AUDIO_ALLOW_FORMAT_CHANGE);
	if (dev == 0) {
		DBGLOGEX(Error,"Failed to open audio: %s", SDL_GetError());
		return -1;
	}
	else {
		if (spec.format != want.format) { /* we let this one thing change. */
			DBGLOGEX(Error, "We didn't get want audio format.");
			SDL_CloseAudioDevice(dev);
			dev = 0;
			return -1;
		}
	}

	return 0;
}
int AudioStream::deinitAudio()
{
	if (dev)
	{
		SDL_CloseAudioDevice(dev);
		dev = 0;
	}
	return 0;
}
#define MAX_AUDIO_FRAME_SIZE 4096
void AudioStream::OpenFile(const std::string& url)
{
	AVFormatContext *pInFmtCtx = NULL;//文件格式
	AVCodecContext *pInCodecCtx = NULL;//编码格式 

	AVFormatContext *pFormatCtx;
	unsigned        i;
	//AVCodecContext  *pCodecCtx;
	//AVCodec         *pCodec;
	//AVPacket        *packet;
	//uint8_t         *out_buffer;
	//AVFrame         *pFrame;
	//struct SwrContext *au_convert_ctx;
	uint32_t len = 0;
	int index = 0;
	//int64_t in_channel_layout;

	pFormatCtx = avformat_alloc_context();
	//Open  
	if (avformat_open_input(&pFormatCtx, url.c_str(), NULL, NULL) != 0) {
		printf("Couldn't open input stream.\n");
		return ;
	}
	// Retrieve stream information  
	if (avformat_find_stream_info(pFormatCtx, NULL)<0) {
		printf("Couldn't find stream information.\n");
		return ;
	}
	AvFmtCtx = pFormatCtx;
	// Find the first audio stream  
	audioIndex = -1;
	for (i = 0; i < pFormatCtx->nb_streams; i++)
		if (pFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
			audioIndex = i;
			break;
		}

	if (audioIndex == -1) {
		printf("Didn't find a audio stream.\n");
		return ;
	}

	double dur = pFormatCtx->streams[i]->duration*av_q2d(pFormatCtx->streams[i]->time_base);
	int hor = (int)(dur / 3600);
	int min = (int)(dur/60-hor*60);
	int sec = (int)(dur-min*60-hor*3600);
	DBGLOG("Duration of %s is %lf,%02d:%02d:%02d", url.c_str(),dur ,
		hor,min,sec
		);
	int dict_num = av_dict_count(AvFmtCtx->metadata);
	AVDictionaryEntry*t;
	printf("dict_num:%d\n", dict_num);
	printf("dict_element:\n");
	for (; t = av_dict_get(AvFmtCtx->metadata, "", t, AV_DICT_IGNORE_SUFFIX);) {
		printf("key:%10s??|??value:%s\n", t->key, t->value);
	}
#if 0
	// Get a pointer to the codec context for the audio stream  
	pCodecCtx = pFormatCtx->streams[audioIndex]->codec;

	// Find the decoder for the audio stream  
	pCodec = avcodec_find_decoder(pCodecCtx->codec_id);
	if (pCodec == NULL) {
		printf("Codec not found.\n");
		return ;
	}

	// Open codec  
	if (avcodec_open2(pCodecCtx, pCodec, NULL)<0) {
		printf("Could not open codec.\n");
		return ;
	}

	packet = (AVPacket *)av_malloc(sizeof(AVPacket));
	av_init_packet(packet);

	//Out Audio Param  
	uint64_t out_channel_layout = AV_CH_LAYOUT_STEREO;

	//nb_samples: AAC-1024 MP3-1152  
	int out_nb_samples = pCodecCtx->frame_size;
	AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;
	int out_sample_rate = 44100;
	int out_channels = av_get_channel_layout_nb_channels(out_channel_layout);
	//Out Buffer Size  
	int out_buffer_size = av_samples_get_buffer_size(NULL, out_channels, out_nb_samples, out_sample_fmt, 1);

	out_buffer = (uint8_t *)av_malloc(MAX_AUDIO_FRAME_SIZE * 2);
	pFrame = av_frame_alloc();

	//FIX:Some Codec's Context Information is missing  
	in_channel_layout = av_get_default_channel_layout(pCodecCtx->channels);
	//Swr  

	au_convert_ctx = swr_alloc();
	au_convert_ctx = swr_alloc_set_opts(au_convert_ctx, out_channel_layout, out_sample_fmt, out_sample_rate,
		in_channel_layout, pCodecCtx->sample_fmt, pCodecCtx->sample_rate, 0, NULL);
	swr_init(au_convert_ctx);

	//Play  
	SDL_PauseAudio(0);
	{
	int ret = avcodec_decode_audio4(pCodecCtx, pFrame, &got_picture, packet);
	av_free_packet(packet);
	}

	swr_free(&au_convert_ctx);
	av_free(out_buffer);
	avcodec_close(pCodecCtx);
#endif
}

void AudioStream::CloseFile()
{
	if(AvFmtCtx)
		avformat_close_input(&AvFmtCtx);
	if (AvCodecCtx)
		avcodec_close(AvCodecCtx);
}

unsigned AudioStream::GetDuration()
{
	double dur = AvFmtCtx->streams[audioIndex]->duration*
		av_q2d(AvFmtCtx->streams[audioIndex]->time_base);
	return (unsigned)(dur*1000);
}

void AudioStream::AudioCallBack(Uint8 * buf, int len)
{
}

AudioStream::AudioStream():AvFmtCtx(NULL),AvCodecCtx(NULL)
{
}


AudioStream::~AudioStream()
{
	CloseFile();
}
